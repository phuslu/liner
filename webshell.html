<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title></title>
    <meta name="description" content="Liner WebShell" />
    <link rel="stylesheet" href="xterm.css" />
    <style>
        body {
            margin: 0;
            height: 100vh;
            background: #000;
            font-family: "ubuntu", "Tahoma", "Microsoft YaHei", Arial, Serif;
        }
        .webshell {
            display: flex;
            flex-direction: column;
            height: 100%;
        }
        .webshell-terminal {
            flex: 1;
        }
        #terminal {
            width: 100%;
            height: 100%;
        }
        #reconnect-overlay {
            display: none;
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.65);
            align-items: center;
            justify-content: center;
        }
        #reconnect-box {
            background: #d0d0d0;
            color: #000;
            padding: 14px 26px;
            border-radius: 12px;
            font-size: 22px;
            font-family: Menlo, Monaco, "Courier New", monospace;
            box-shadow: 0 0 12px rgba(0, 0, 0, 0.45);
        }
    </style>
    <script src="xterm.js"></script>
    <script src="xterm-addon-fit.js"></script>
    <script src="xterm-addon-webgl.js"></script>
    <script src="xterm-addon-web-links.js"></script>
</head>
<body>
    <div class="webshell">
        <div id="terminal" class="webshell-terminal"></div>
        <div id="reconnect-overlay"><div id="reconnect-box">Press ‚èé to Reconnect</div></div>
    </div>

    <script>
        document.title = "{{ index .Template `title` }}" || "liner webshell";

        const term = new Terminal({
            allowProposedApi: true,
            cursorBlink: true,
            disableStdin: false,
            fontSize: parseInt("{{ .Request.URL.Query.Get `font_size` | default (index .Template `font_size`) }}") || 14,
            fontFamily: 'Menlo, Monaco, "Courier New", monospace',
            theme: { background: '#101010' },
            scrollback: 5000,
            windowsMode: "{{ .Request.URL.Query.Get `windows_mode` | default (index .Template `windows_mode`) }}" == "true",
        });

        const fitAddon = new FitAddon.FitAddon();
        term.loadAddon(fitAddon);

        try {
            const webglAddon = new WebglAddon.WebglAddon();
            webglAddon.onContextLoss(e => { webglAddon.dispose(); });
            term.loadAddon(webglAddon);
        } catch (e) {
            console.warn("WebGL not supported, falling back to canvas");
        }

        term.loadAddon(new WebLinksAddon.WebLinksAddon());

        const terminal = document.getElementById('terminal');
        term.open(terminal);
        fitAddon.fit();

        const overlay = document.getElementById('reconnect-overlay');
        let reconnectMode = false;

        function showReconnectOverlay() {
            reconnectMode = true;
            overlay.style.display = 'flex';
            term.blur();
            term.write('\r\n\x1b[31mSession Ended\x1b[0m\r\n');
        }

        function hideReconnectOverlay() {
            reconnectMode = false;
            overlay.style.display = 'none';
            term.focus();
        }

        const ws = new WebSocket(
            location.protocol.replace('http', 'ws') + '//' +
            location.host +
            location.pathname.replace(/\/[^/]*$/, '') + '/ws'
        );
        ws.binaryType = 'arraybuffer';

        let framePending = false;
        let queue = [];

        ws.onmessage = (event) => {
            if (event.data instanceof ArrayBuffer) {
                queue.push(new Uint8Array(event.data));
            } else {
                queue.push(event.data);
            }
            if (!framePending) {
                framePending = true;
                requestAnimationFrame(flushQueue);
            }
        };

        const decoder = new TextDecoder();
        function flushQueue() {
            framePending = false;
            for (let i = 0; i < queue.length; i++) {
                const chunk = queue[i];
                if (chunk instanceof Uint8Array) {
                    try {
                        term.writeUtf8(chunk);
                    } catch (_) {
                        term.write(decoder.decode(chunk));
                    }
                } else {
                    term.write(chunk);
                }
            }
            queue.length = 0;
        }

        ws.onopen = () => {
            hideReconnectOverlay();
            sendResize();
        };

        ws.onclose = () => {
            showReconnectOverlay();
        };

        const encoder = new TextEncoder();
        term.onData((data) => {
            if (reconnectMode) return;
            if (ws.readyState === WebSocket.OPEN) {
                ws.send(encoder.encode(data));
            }
        });

        function sendResize() {
            if (ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: 'resize',
                    cols: term.cols,
                    rows: term.rows
                }));
            }
        }

        const resizeObserver = new ResizeObserver(entries => {
            requestAnimationFrame(() => {
                if (!entries.length) return;
                try {
                    fitAddon.fit();
                    sendResize();
                } catch (e) {}
            });
         });

        resizeObserver.observe(terminal);

        window.addEventListener('keydown', (e) => {
            if (reconnectMode && e.key === 'Enter') {
                location.reload();
            }
        });
    </script>
</body>
</html>
